<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Cinematic Golden Black Hole</title>
  <style>
    :root{ color-scheme: dark; }
    html,body{ height:100%; margin:0; background:#02020a; overflow:hidden;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    #c{ position:fixed; inset:0; width:100%; height:100%; display:block; }

    #ui{
      position:fixed; left:12px; top:12px; z-index:5;
      display:flex; flex-direction:column; gap:10px;
      padding:10px 10px 12px;
      border-radius:14px;
      background:rgba(7,7,16,.58);
      border:1px solid rgba(255,255,255,.08);
      box-shadow:0 10px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      user-select:none;
      max-width:min(560px, calc(100vw - 24px));
    }
    #ui .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    #ui .row.tight{ gap:6px; }
    #ui h1{ margin:0; font-size:12px; letter-spacing:.14em; text-transform:uppercase; opacity:.88; }
    button{
      appearance:none; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:8px 10px; border-radius:12px;
      font-weight:600; font-size:12px;
      cursor:pointer;
    }
    button:hover{ background:rgba(255,255,255,.09); }
    button:active{ transform: translateY(1px); }
    label{ font-size:12px; opacity:.92; display:flex; align-items:center; gap:8px; }
    input[type="range"]{ width:180px; }
    select{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:8px 10px; border-radius:12px; font-weight:600; font-size:12px;
    }
    .pill{ padding:6px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05); font-size:12px; opacity:.92; }
    .muted{ opacity:.65; }
    #help{ font-size:12px; opacity:.72; line-height:1.35; }
    #toggleUI{ position:fixed; right:12px; top:12px; z-index:6; }
    @media (max-width:480px){ input[type="range"]{ width:150px; } }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <button id="toggleUI" class="pill">Hide UI</button>
  <div id="ui">
    <h1>Cinematic Black Hole</h1>

    <div class="row">
      <button id="play">Pause</button>
      <button id="focus">Focus horizon</button>
      <button id="reset">Reset view</button>
      <button id="random">New seed</button>
      <span class="pill" id="fps">— fps</span>
    </div>

    <div class="row tight">
      <label><input id="anom" type="checkbox" checked /> Horizon anomalies</label>
      <label><input id="sparks" type="checkbox" checked /> Horizon sparks</label>
      <label><input id="cine" type="checkbox" checked /> Cinematic</label>
    </div>

    <div class="row">
      <label>Zoom <input id="zoom" type="range" min="0.55" max="18" step="0.01" value="1.4" /> <span class="pill" id="zoomV">1.40×</span></label>
      <label>Inclination <input id="inc" type="range" min="0" max="82" step="1" value="68" /> <span class="pill" id="incV">68°</span></label>
    </div>

    <div class="row">
      <label>Mass <input id="mass" type="range" min="0.14" max="0.34" step="0.001" value="0.22" /> <span class="pill" id="massV">0.220</span></label>
    </div>

    <div class="row">
      <label>Disk intensity <input id="diskI" type="range" min="0" max="2.8" step="0.01" value="1.0" /> <span class="pill" id="diskIV">1.00</span></label>
      <label>Disk radius <input id="diskR" type="range" min="4.5" max="10.5" step="0.01" value="6.9" /> <span class="pill" id="diskRV">6.90</span></label>
    </div>

    <div class="row">
      <label>Disk thickness <input id="thick" type="range" min="0.04" max="0.16" step="0.001" value="0.074" /> <span class="pill" id="thickV">0.074</span></label>
      <label>Sparks <input id="sparkAmt" type="range" min="0" max="2.2" step="0.01" value="1.0" /> <span class="pill" id="sparkV">1.00</span></label>
    </div>

    <div class="row">
      <label>Bloom <input id="bloom" type="range" min="0" max="2.4" step="0.01" value="1.25" /> <span class="pill" id="bloomV">1.25</span></label>
      <label>Speed <input id="speed" type="range" min="0" max="1.8" step="0.01" value="1" /> <span class="pill" id="speedV">1.00</span></label>
      <label class="muted">Quality
        <select id="q">
          <option value="1">Ultra</option>
          <option value="0.75" selected>High</option>
          <option value="0.55">Balanced</option>
          <option value="0.4">Performance</option>
        </select>
      </label>
    </div>

    <div id="help" class="muted">
      Drag to pan · wheel/trackpad to zoom · Space = pause · H = toggle UI · F = focus
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ---------- tiny utils ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now()*0.001;

  // Deterministic RNG hash
  function xmur3(str){
    let h=1779033703^str.length;
    for(let i=0;i<str.length;i++){
      h=Math.imul(h^str.charCodeAt(i),3432918353);
      h=(h<<13)|(h>>>19);
    }
    return function(){
      h=Math.imul(h^(h>>>16),2246822507);
      h=Math.imul(h^(h>>>13),3266489909);
      return (h^=h>>>16)>>>0;
    };
  }

  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ui = document.getElementById('ui');
  const toggleUI = document.getElementById('toggleUI');
  const playBtn = document.getElementById('play');
  const focusBtn = document.getElementById('focus');
  const resetBtn = document.getElementById('reset');
  const randomBtn = document.getElementById('random');
  const fpsEl = document.getElementById('fps');

  const zoomEl = document.getElementById('zoom');
  const zoomV = document.getElementById('zoomV');
  const incEl = document.getElementById('inc');
  const incV = document.getElementById('incV');
  const bloomEl = document.getElementById('bloom');
  const bloomV = document.getElementById('bloomV');
  const speedEl = document.getElementById('speed');
  const speedV = document.getElementById('speedV');
  const qEl = document.getElementById('q');

  const massEl = document.getElementById('mass');
  const massV = document.getElementById('massV');
  const diskIEl = document.getElementById('diskI');
  const diskIV = document.getElementById('diskIV');
  const diskREl = document.getElementById('diskR');
  const diskRV = document.getElementById('diskRV');
  const thickEl = document.getElementById('thick');
  const thickV = document.getElementById('thickV');
  const sparkAmtEl = document.getElementById('sparkAmt');
  const sparkV = document.getElementById('sparkV');

  const anomEl = document.getElementById('anom');
  const sparksEl = document.getElementById('sparks');
  const cineEl = document.getElementById('cine');

  let paused = false;

  // ---------- WebGL2 setup ----------
  const gl = canvas.getContext('webgl2', { antialias:false, alpha:false, depth:false, stencil:false, preserveDrawingBuffer:false });
  if(!gl){
    document.body.innerHTML = '<div style="padding:18px;color:#fff;font-family:system-ui">WebGL2 not supported in this browser.</div>';
    return;
  }

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      const msg = gl.getShaderInfoLog(sh) || 'Shader compile error';
      console.error(msg, src);
      throw new Error(msg);
    }
    return sh;
  }
  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      const msg = gl.getProgramInfoLog(p) || 'Program link error';
      console.error(msg);
      throw new Error(msg);
    }
    return p;
  }

  const quadVS = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 aPos;
    out vec2 vUv;
    void main(){
      vUv = aPos*0.5 + 0.5;
      gl_Position = vec4(aPos, 0.0, 1.0);
    }
  `;

  // ----- Main scene (linear color; post handles tonemap/bloom) -----
  const bhFS = `#version 300 es
    precision highp float;
    out vec4 frag;
    in vec2 vUv;

    uniform vec2 uRes;
    uniform float uTime;
    uniform float uZoom;
    uniform float uInc;
    uniform float uSeed;
    uniform vec2 uPan;
    uniform float uSpeed;
    uniform float uAnom;
    uniform float uCine;

    uniform float uRs;
    uniform float uDiskI;
    uniform float uRoutMul;
    uniform float uThick;
    uniform float uSparkAmt;
    uniform float uSparksOn;

    float hash12(vec2 p){
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    float noise(vec2 p){
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash12(i);
      float b = hash12(i + vec2(1.0,0.0));
      float c = hash12(i + vec2(0.0,1.0));
      float d = hash12(i + vec2(1.0,1.0));
      vec2 u = f*f*(3.0-2.0*f);
      return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
    }

    float fbm(vec2 p){
      float v = 0.0;
      float a = 0.55;
      mat2 m = mat2(1.7,1.2,-1.2,1.7);
      for(int i=0;i<6;i++){
        v += a*noise(p);
        p = m*p;
        a *= 0.5;
      }
      return v;
    }

    vec2 rot(vec2 p, float a){
      float s = sin(a), c = cos(a);
      return vec2(c*p.x - s*p.y, s*p.x + c*p.y);
    }

    float doppler(float beta, float vlos){
      float denom = max(0.12, 1.0 - beta*vlos);
      return pow(1.0/denom, 3.1);
    }

    float sparkLayer(vec2 pol, float t, float seed, float gridA, float gridR, float keep, float sharp){
      vec2 g = vec2(pol.x*gridA, pol.y*gridR + t);
      vec2 i = floor(g);
      vec2 f = fract(g);
      float h = hash12(i + seed);
      vec2 off = vec2(hash12(i + seed + 11.7), hash12(i + seed + 27.3));
      vec2 p = 0.5 + (off - 0.5) * 0.65;
      vec2 d = (f - p);
      d.x *= 1.2;
      float dist2 = dot(d,d);
      float s = exp(-dist2 * sharp);
      float tw = 0.55 + 0.45*sin(t*7.0 + h*10.0);
      return s * tw * step(keep, h);
    }

    void main(){
      vec2 p = (vUv*2.0 - 1.0);
      float aspect = uRes.x / uRes.y;
      p.x *= aspect;

      // camera space (pan/zoom)
      p = p / max(0.001, uZoom) + uPan;

      float rs = uRs;
      float shadow = rs*1.14;
      float photon = rs*1.58;

      float t = uTime * uSpeed;
      float inc = radians(uInc);

      float r = length(p);
      float phi = atan(p.y, p.x);

      float nearH = 1.0 - smoothstep(rs*1.2, rs*4.8, r);
      float anom = uAnom * nearH;

      // lensing deflection (derived from mass; no separate lens slider)
      float def = (rs*rs) / (r*r + 0.004);
      def *= smoothstep(rs*0.95, rs*7.5, r);
      def *= mix(0.82, 1.05, uCine);

      float shimmer = (fbm(p*18.0 + vec2(0.0, t*0.55) + uSeed) - 0.5);
      def *= 1.0 + anom*(0.26*shimmer);

      vec2 lp = rot(p, def);
      lp *= (1.0 + def*0.24);

      vec3 col = vec3(0.0);

      // ----- Deep background (stars + nebula) -----
      vec2 sp = lp*1.75;
      float s = 0.0;
      for(int i=0;i<3;i++){
        vec2 g = floor(sp*38.0 + float(i)*17.3);
        float h = hash12(g + uSeed);
        vec2 f = fract(sp*38.0);
        float d = length(f - 0.5);
        float star = smoothstep(0.060, 0.0, d) * smoothstep(0.997, 1.0, h);
        float tw = 0.65 + 0.35*sin(t*2.0 + h*9.0);
        s += star * tw * (0.70 + 0.40*hash12(g + 9.1));
        sp = rot(sp, 1.15);
      }

      float neb1 = fbm(lp*1.2 + vec2(t*0.012, -t*0.010) + uSeed*0.13);
      float neb2 = fbm(lp*2.4 + vec2(-t*0.006, t*0.008) + uSeed*0.31);
      float neb = pow(clamp(0.55*neb1 + 0.45*neb2, 0.0, 1.0), 2.15);

      vec3 nebCol = vec3(0.018,0.024,0.050)
        + 0.20*vec3(0.16,0.24,0.90)*neb
        + 0.08*vec3(0.75,0.22,0.10)*pow(neb2, 3.0);

      col += nebCol;
      col += vec3(1.25,1.30,1.40) * s;

      // ----- Accretion disk (beaming + redshift + layered structure) -----
      vec2 dp = lp;
      float drag = 0.28 * (rs / (r + rs));
      drag *= 1.0 + anom*0.75;
      dp = rot(dp, drag);

      float cI = max(0.16, cos(inc));
      vec2 q = vec2(dp.x, dp.y / cI);
      float dr = length(q);
      float dphi = atan(q.y, q.x);

      float rin = rs*1.22;
      float rout = rs*uRoutMul;

      float thickness = uThick + 0.055*fbm(vec2(dphi*1.6, dr*9.4) + vec2(t*0.62, -t*0.28) + uSeed);
      thickness *= 1.0 + anom*1.0;

      float band = exp(-pow(abs(q.y) / (thickness + 1e-4), 1.30));
      float diskMask = band;
      diskMask *= smoothstep(rin, rin + rs*0.20, dr);
      diskMask *= 1.0 - smoothstep(rout - rs*0.28, rout, dr);

      // High-detail "layered" look: filaments + shear + many thin radial bands
      float fil = fbm(vec2(dphi*9.2, dr*12.0) + vec2(t*1.55, -t*0.85) + uSeed*2.1);
      float swirl = fbm(vec2(dr*7.2, dphi*3.4) + vec2(-t*0.40, t*0.62) + uSeed*3.7);
      float arms = sin(dphi*2.0 + t*2.35) * 0.5 + 0.5;

      float lr = log(max(1e-3, dr/rs));
      float shear = sin(dphi*12.0 + lr*7.0 + t*1.20) * 0.5 + 0.5;

      float bands = 0.0;
      bands += 0.5 + 0.5*sin(lr*22.0 + t*0.80 + uSeed*1.7);
      bands += 0.5 + 0.5*sin(lr*38.0 - t*1.05 + uSeed*3.4);
      bands += 0.5 + 0.5*sin(lr*64.0 + t*1.35 + uSeed*5.1);
      bands = (bands/3.0);
      bands = pow(clamp(bands, 0.0, 1.0), 2.2);

      float ringlets = pow(abs(sin(lr*120.0 + t*0.55 + uSeed*2.3)), 18.0);
      ringlets *= smoothstep(rin + rs*0.2, rin + rs*1.6, dr);
      ringlets *= 1.0 - smoothstep(rout - rs*0.6, rout, dr);

      float structure = 0.44*fil + 0.16*swirl + 0.14*arms + 0.26*shear;
      structure = clamp(structure, 0.0, 1.0);
      float layerDetail = clamp(0.70*bands + 0.55*ringlets, 0.0, 1.0);
      structure = clamp(0.45*structure + 0.90*layerDetail, 0.0, 1.0);
      structure = pow(structure, 1.12);

      float beta = clamp(0.82 * sqrt(rin / max(dr, rin)), 0.0, 0.88);
      float vlos = sin(dphi) * sin(inc);
      float beam = doppler(beta, vlos);
      float gred = sqrt(max(0.0, 1.0 - rs / max(dr, rs*1.02)));

      // Cinematic mode: mild Doppler tint (blue on approach, warm on recede)
      float side = smoothstep(-0.18, 0.18, vlos);
      vec3 blueTint = vec3(0.70, 0.95, 1.35);
      vec3 redTint  = vec3(1.20, 0.78, 0.40);

      vec3 hot  = mix(vec3(1.95, 1.25, 0.42), vec3(1.45, 1.75, 2.30), uCine);
      vec3 warm = mix(vec3(1.25, 0.68, 0.20), vec3(0.52, 0.92, 1.65), uCine);
      vec3 ember= mix(vec3(0.52, 0.18, 0.06), vec3(0.18, 0.30, 0.58), uCine*0.55);

      float heat = smoothstep(rout, rin, dr);
      vec3 diskCol = mix(ember, warm, pow(heat, 0.82));
      diskCol = mix(diskCol, hot,  pow(heat, 2.75));

      vec3 vTint = mix(redTint, blueTint, side);
      diskCol *= mix(vec3(1.0), vTint, 0.30*uCine);

      diskCol *= mix(0.52, 1.0, gred);
      diskCol *= (0.48 + 1.85*structure) * uDiskI;

      float innerGlow = exp(-pow((dr - rin) / (rs*0.115), 2.0));
      diskCol += innerGlow * mix(vec3(2.1, 1.35, 0.48), vec3(1.4, 2.0, 2.3), uCine) * (0.30 + 0.85*structure) * uDiskI;

      float flick = fbm(q*22.0 + vec2(t*2.05, -t*1.38) + uSeed);
      diskCol *= 1.0 + anom*(0.20*(flick - 0.45));

      diskCol *= diskMask * beam;
      col += diskCol;

      // secondary lensed disk image (helps create the extra ring)
      vec2 q2 = q;
      q2.y = -q2.y;
      float dr2 = length(q2);
      float dphi2 = atan(q2.y, q2.x);
      float band2 = exp(-pow(abs(q2.y) / (thickness*0.85 + 1e-4), 1.35));
      float disk2 = band2;
      disk2 *= smoothstep(rin, rin + rs*0.20, dr2);
      disk2 *= 1.0 - smoothstep(rout - rs*0.28, rout, dr2);
      float beta2 = clamp(0.80 * sqrt(rin / max(dr2, rin)), 0.0, 0.86);
      float vlos2 = sin(dphi2) * sin(inc);
      float side2 = smoothstep(-0.18, 0.18, vlos2);
      float beam2 = doppler(beta2, vlos2);
      float g2 = sqrt(max(0.0, 1.0 - rs / max(dr2, rs*1.02)));

      float lr2 = log(max(1e-3, dr2/rs));
      float bands2 = 0.0;
      bands2 += 0.5 + 0.5*sin(lr2*24.0 + t*0.78 + uSeed*1.2);
      bands2 += 0.5 + 0.5*sin(lr2*44.0 - t*1.10 + uSeed*2.6);
      bands2 = pow(clamp(bands2*0.5, 0.0, 1.0), 2.0);

      vec3 diskCol2 = mix(ember, warm, pow(smoothstep(rout, rin, dr2), 0.85));
      diskCol2 = mix(diskCol2, hot, pow(smoothstep(rout, rin, dr2), 2.6));
      diskCol2 *= mix(vec3(1.0), mix(redTint, blueTint, side2), 0.30*uCine);
      diskCol2 *= mix(0.55, 1.0, g2);
      diskCol2 *= (0.45 + 1.25*bands2) * beam2 * uDiskI;

      float arcMix = pow(nearH, 2.0) * smoothstep(rs*1.35, rs*0.95, r);
      col += diskCol2 * disk2 * (0.40 + 0.60*arcMix) * arcMix;

      // ----- in-shader sparks (always in tune with lensing) -----
      if(uSparksOn > 0.5){
        vec2 pol = vec2(dphi, dr/rs);
        float gate = diskMask;
        gate *= smoothstep(1.08, 1.45, pol.y);
        gate *= 1.0 - smoothstep(3.4, 4.8, pol.y);

        float nh = 1.0 - smoothstep(rs*1.05, rs*2.4, dr);
        float dust = pow(max(0.0, fbm(vec2(dphi*10.0, pol.y*7.5) + vec2(t*0.9, -t*0.4) + uSeed*2.0) - 0.56), 1.7);

        float L1 = sparkLayer(vec2(dphi, pol.y), t*0.75, uSeed*7.1, 18.0, 6.0, 0.93, 56.0);
        float L2 = sparkLayer(vec2(dphi, pol.y), t*1.05, uSeed*9.3, 28.0, 8.5, 0.955, 92.0);
        float L3 = sparkLayer(vec2(dphi, pol.y), t*0.55, uSeed*4.9, 12.0, 5.0, 0.90, 42.0);

        float sparks = (L1*0.65 + L2*0.85 + L3*0.45);
        sparks += dust * (0.45 + 0.55*nh);

        float edge = smoothstep(shadow + rs*0.08, shadow - rs*0.02, r);
        sparks *= gate * (1.0 - edge);

        vec3 sparkCol = mix(vec3(2.0, 1.55, 0.75), vec3(0.95, 1.55, 2.25), uCine*side);
        col += sparks * sparkCol * uSparkAmt;
      }

      // ----- Photon ring + corona -----
      float ring = exp(-pow((r - photon) / (rs*0.085), 2.0));
      ring *= 0.35 + 0.65*fbm(vec2(phi*6.0, r*26.0) + vec2(t*0.95, -t*0.75) + uSeed);

      vec3 ringCol = mix(vec3(1.55, 1.20, 0.65), vec3(0.75, 1.10, 1.95), uCine);
      ringCol *= mix(vec3(1.05,0.95,0.90), vec3(0.85,1.05,1.35), side*uCine);
      col += ring * ringCol * (1.0 + 0.35*uCine);

      float edge = smoothstep(shadow + rs*0.08, shadow - rs*0.02, r);

      // swallow light near the shadow edge
      col *= 1.0 - 0.94*edge;

      // black core
      float core = smoothstep(rs*1.02, rs*0.98, r);
      col = mix(col, vec3(0.0), core);

      // warm corona halo
      float halo = exp(-pow((r - shadow) / (rs*0.16), 2.0));
      float haloFine = fbm(vec2(phi*3.0, r*14.0) + vec2(t*0.3, -t*0.22) + uSeed*0.3);
      col += halo * mix(vec3(0.24, 0.19, 0.14), vec3(0.14, 0.22, 0.36), uCine) * (0.5 + 0.5*haloFine) * (0.85 + 0.65*uCine);

      float vig = smoothstep(1.50, 0.22, length((vUv-0.5)*vec2(aspect,1.0)));
      col *= 0.70 + 0.30*vig;

      col = min(col, vec3(10.0));
      frag = vec4(col, 1.0);
    }
  `;

  // ----- Post (bloom via mip LODs + filmic tonemap + subtle CA/grain) -----
  const postFS = `#version 300 es
    precision highp float;
    out vec4 frag;
    in vec2 vUv;

    uniform sampler2D uScene;
    uniform vec2 uRes;
    uniform float uTime;
    uniform float uBloom;
    uniform float uCine;

    uniform float uZoom;
    uniform vec2 uPan;
    uniform float uRs;

    float hash12(vec2 p){
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    vec3 tonemapFilmic(vec3 x){
      x = max(x, 0.0);
      x = (x*(2.20*x + 0.05)) / (x*(2.20*x + 1.20) + 0.05);
      return x;
    }

    void main(){
      vec2 uv = vUv;

      // chromatic aberration (subtle)
      float ca = 0.0018 * uCine;
      vec2 d = (uv - 0.5);
      vec2 o = d * (0.65 + 0.35*length(d)) * ca;

      vec3 base;
      base.r = texture(uScene, uv + o).r;
      base.g = texture(uScene, uv).g;
      base.b = texture(uScene, uv - o).b;

      // bloom from lower mips
      vec3 b2 = textureLod(uScene, uv, 2.0).rgb;
      vec3 b3 = textureLod(uScene, uv, 3.2).rgb;
      vec3 b4 = textureLod(uScene, uv, 4.4).rgb;
      vec3 bloom = (b2*0.80 + b3*0.55 + b4*0.35);
      bloom = max(bloom - 0.10, 0.0);
      base += bloom * (0.65 * uBloom);

      float v = smoothstep(0.95, 0.25, length((uv-0.5)*vec2(uRes.x/uRes.y,1.0)));
      base *= mix(0.82, 1.0, v);

      // film grain
      float g = hash12(uv*uRes + vec2(uTime*120.0, uTime*37.0));
      float grain = (g - 0.5) * 0.06 * uCine;
      base *= 1.0 + grain;

      float grit = pow(hash12(uv*uRes*0.35 + uTime*9.0), 18.0) * uCine;
      base += grit * 0.10;

      // Hard mask the black hole shadow so it stays perfectly black (even with bloom)
      float aspect = uRes.x / uRes.y;
      vec2 p = (uv*2.0 - 1.0);
      p.x *= aspect;
      p = p / max(0.001, uZoom) + uPan;

      float shadow = uRs*1.14;
      float hole = smoothstep(shadow*1.01, shadow*0.98, length(p));
      base *= (1.0 - hole);

      vec3 outc = tonemapFilmic(base);
      outc = pow(outc, vec3(1.0/2.2));
      frag = vec4(outc, 1.0);
    }
  `;

  const progBH = link(compile(gl.VERTEX_SHADER, quadVS), compile(gl.FRAGMENT_SHADER, bhFS));
  const progPost = link(compile(gl.VERTEX_SHADER, quadVS), compile(gl.FRAGMENT_SHADER, postFS));

  // Fullscreen quad
  const quad = gl.createVertexArray();
  gl.bindVertexArray(quad);
  const qb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, qb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1,  -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
  gl.bindVertexArray(null);

  // Uniforms (scene)
  const U = {
    res: gl.getUniformLocation(progBH, 'uRes'),
    time: gl.getUniformLocation(progBH, 'uTime'),
    zoom: gl.getUniformLocation(progBH, 'uZoom'),
    inc: gl.getUniformLocation(progBH, 'uInc'),
    seed: gl.getUniformLocation(progBH, 'uSeed'),
    pan: gl.getUniformLocation(progBH, 'uPan'),
    speed: gl.getUniformLocation(progBH, 'uSpeed'),
    anom: gl.getUniformLocation(progBH, 'uAnom'),
    cine: gl.getUniformLocation(progBH, 'uCine'),

    rs: gl.getUniformLocation(progBH, 'uRs'),
    diskI: gl.getUniformLocation(progBH, 'uDiskI'),
    rout: gl.getUniformLocation(progBH, 'uRoutMul'),
    thick: gl.getUniformLocation(progBH, 'uThick'),
    sparkAmt: gl.getUniformLocation(progBH, 'uSparkAmt'),
    sparksOn: gl.getUniformLocation(progBH, 'uSparksOn'),
  };

  // Uniforms (post)
  const P = {
    res: gl.getUniformLocation(progPost, 'uRes'),
    time: gl.getUniformLocation(progPost, 'uTime'),
    bloom: gl.getUniformLocation(progPost, 'uBloom'),
    cine: gl.getUniformLocation(progPost, 'uCine'),
    zoom: gl.getUniformLocation(progPost, 'uZoom'),
    pan: gl.getUniformLocation(progPost, 'uPan'),
    rs: gl.getUniformLocation(progPost, 'uRs'),
    scene: gl.getUniformLocation(progPost, 'uScene'),
  };

  // ---------- Camera / controls ----------
  let zoom = parseFloat(zoomEl.value); // starts at ~1.4x for a wide, cinematic establishing view
  let inc = parseFloat(incEl.value);
  let bloomAmt = parseFloat(bloomEl.value);
  let speed = parseFloat(speedEl.value);

  let rs = parseFloat(massEl.value);
  let diskI = parseFloat(diskIEl.value);
  let routMul = parseFloat(diskREl.value);
  let thick = parseFloat(thickEl.value);
  let sparkAmt = parseFloat(sparkAmtEl.value);

  let anomOn = anomEl.checked;
  let sparksOn = sparksEl.checked;
  let cineOn = cineEl.checked;

  let panX = 0, panY = 0;
  let drag = false;
  let lastX = 0, lastY = 0;

  function setLabels(){
    zoomV.textContent = `${zoom.toFixed(2)}×`;
    incV.textContent = `${Math.round(inc)}°`;
    bloomV.textContent = `${bloomAmt.toFixed(2)}`;
    speedV.textContent = `${speed.toFixed(2)}`;

    massV.textContent = rs.toFixed(3);
    diskIV.textContent = diskI.toFixed(2);
    diskRV.textContent = routMul.toFixed(2);
    thickV.textContent = thick.toFixed(3);
    sparkV.textContent = sparkAmt.toFixed(2);
  }
  setLabels();

  function resetView(){
    zoom = 1.4;
    inc = 68;
    bloomAmt = 1.25;
    speed = 1.0;

    rs = 0.22;
    diskI = 1.0;
    routMul = 6.9;
    thick = 0.074;
    sparkAmt = 1.0;

    panX = 0; panY = 0;

    zoomEl.value = zoom;
    incEl.value = inc;
    bloomEl.value = bloomAmt;
    speedEl.value = speed;

    massEl.value = rs;
    diskIEl.value = diskI;
    diskREl.value = routMul;
    thickEl.value = thick;
    sparkAmtEl.value = sparkAmt;

    setLabels();
  }

  function focusHorizon(){
    zoom = 10.5;
    panX = 0; panY = 0;
    zoomEl.value = zoom;
    setLabels();
  }

  zoomEl.addEventListener('input', () => { zoom = parseFloat(zoomEl.value); setLabels(); });
  incEl.addEventListener('input', () => { inc = parseFloat(incEl.value); setLabels(); });
  bloomEl.addEventListener('input', () => { bloomAmt = parseFloat(bloomEl.value); setLabels(); });
  speedEl.addEventListener('input', () => { speed = parseFloat(speedEl.value); setLabels(); });

  massEl.addEventListener('input', () => { rs = parseFloat(massEl.value); setLabels(); });
  diskIEl.addEventListener('input', () => { diskI = parseFloat(diskIEl.value); setLabels(); });
  diskREl.addEventListener('input', () => { routMul = parseFloat(diskREl.value); setLabels(); });
  thickEl.addEventListener('input', () => { thick = parseFloat(thickEl.value); setLabels(); });
  sparkAmtEl.addEventListener('input', () => { sparkAmt = parseFloat(sparkAmtEl.value); setLabels(); });

  anomEl.addEventListener('change', () => { anomOn = anomEl.checked; });
  sparksEl.addEventListener('change', () => { sparksOn = sparksEl.checked; });
  cineEl.addEventListener('change', () => { cineOn = cineEl.checked; });

  document.getElementById('toggleUI').addEventListener('click', () => {
    const hidden = ui.style.display === 'none';
    ui.style.display = hidden ? '' : 'none';
    toggleUI.textContent = hidden ? 'Hide UI' : 'Show UI';
  });

  playBtn.addEventListener('click', () => {
    paused = !paused;
    playBtn.textContent = paused ? 'Play' : 'Pause';
  });
  resetBtn.addEventListener('click', resetView);
  focusBtn.addEventListener('click', focusHorizon);

  // Scroll / pinch zoom
  window.addEventListener('wheel', (e) => {
    e.preventDefault();
    const dir = Math.sign(e.deltaY);
    const factor = Math.exp(-dir * 0.08);
    zoom = clamp(zoom * factor, parseFloat(zoomEl.min), parseFloat(zoomEl.max));
    zoomEl.value = zoom;
    setLabels();
  }, { passive:false });

  // ---------- Quality / resize ----------
  let w=0, h=0, dpr=1, q=0.75;

  // Offscreen scene target (for bloom/post)
  let sceneTex = null, sceneFBO = null;
  let useFloat = false;

  const extFloat = gl.getExtension('EXT_color_buffer_float');
  const extHalfLinear = gl.getExtension('OES_texture_half_float_linear');
  useFloat = !!(extFloat && extHalfLinear);

  function createSceneTarget(){
    if(sceneTex) gl.deleteTexture(sceneTex);
    if(sceneFBO) gl.deleteFramebuffer(sceneFBO);

    sceneTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, sceneTex);

    const internalFormat = useFloat ? gl.RGBA16F : gl.RGBA8;
    const type = useFloat ? gl.HALF_FLOAT : gl.UNSIGNED_BYTE;

    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, gl.RGBA, type, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);

    sceneFBO = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, sceneTex, 0);

    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if(status !== gl.FRAMEBUFFER_COMPLETE){
      // Fallback to RGBA8
      useFloat = false;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.deleteFramebuffer(sceneFBO);
      gl.deleteTexture(sceneTex);
      sceneTex = null; sceneFBO = null;

      sceneTex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, sceneTex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);

      sceneFBO = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, sceneTex, 0);
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  function resize(){
    const cssW = Math.max(1, Math.floor(window.innerWidth));
    const cssH = Math.max(1, Math.floor(window.innerHeight));
    dpr = Math.min(2.0, window.devicePixelRatio || 1);
    q = parseFloat(qEl.value);
    w = Math.max(2, Math.floor(cssW * dpr * q));
    h = Math.max(2, Math.floor(cssH * dpr * q));
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    gl.viewport(0,0,w,h);
    createSceneTarget();
  }
  qEl.addEventListener('change', resize);
  window.addEventListener('resize', resize);
  resize();

  // Drag to pan (in scene units)
  function pointerPos(ev){
    const rect = canvas.getBoundingClientRect();
    return { x: (ev.clientX - rect.left), y: (ev.clientY - rect.top) };
  }
  canvas.addEventListener('pointerdown', (e) => {
    drag = true;
    canvas.setPointerCapture(e.pointerId);
    const p = pointerPos(e);
    lastX = p.x; lastY = p.y;
  });
  canvas.addEventListener('pointerup', () => { drag = false; });
  canvas.addEventListener('pointercancel', () => { drag = false; });
  canvas.addEventListener('pointermove', (e) => {
    if(!drag) return;
    if(w <= 2 || h <= 2) return;

    const p = pointerPos(e);
    const dx = p.x - lastX;
    const dy = p.y - lastY;
    lastX = p.x; lastY = p.y;

    const aspect = w / h;
    const sx = (dx / w) * 2.0 * aspect;
    const sy = (dy / h) * 2.0;
    panX -= sx / zoom;
    panY += sy / zoom;
  });

  // ---------- Seed ----------
  let seedStr = (location.hash.match(/seed=([^&]+)/)?.[1] || '').trim();
  if(!seedStr) seedStr = String(Math.floor(Math.random()*1e9));

  // declared before use
  let uSeedVal = 0.0;

  function setSeed(str){
    seedStr = str;
    const h = xmur3(seedStr);
    const a = h();
    const b = h();
    uSeedVal = (a/4294967296)*1000.0 + (b/4294967296)*0.001;

    const params = new URLSearchParams(location.hash.replace(/^#/,''));
    params.set('seed', seedStr);
    history.replaceState(null,'', '#'+params.toString());
  }

  setSeed(seedStr);
  randomBtn.addEventListener('click', () => setSeed(String(Math.floor(Math.random()*1e9))));

  // ---------- lightweight self-tests (non-throwing) ----------
  (function runSelfTests(){
    console.assert(typeof uSeedVal === 'number' && Number.isFinite(uSeedVal), 'SelfTest: uSeedVal should be a finite number');
    console.assert(sceneFBO !== null && sceneTex !== null, 'SelfTest: scene target should be created');
  })();

  // ---------- Render loop ----------
  let tHold = now();
  let last = tHold;
  let fpsAcc=0, fpsN=0, fpsLast=performance.now();

  function step(){
    requestAnimationFrame(step);

    const t = now();
    const dt = clamp(t - last, 0.0, 0.05);
    last = t;

    // FPS
    const ms = performance.now();
    fpsAcc += 1.0/Math.max(1e-6, dt);
    fpsN++;
    if(ms - fpsLast > 420){
      const avg = fpsAcc / Math.max(1,fpsN);
      fpsEl.textContent = `${avg.toFixed(0)} fps`;
      fpsAcc=0; fpsN=0; fpsLast=ms;
    }

    const time = paused ? tHold : t;
    if(!paused) tHold = time;

    // ----- PASS 1: render to scene texture -----
    gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO);
    gl.viewport(0,0,w,h);
    gl.disable(gl.BLEND);

    gl.useProgram(progBH);
    gl.bindVertexArray(quad);

    gl.uniform2f(U.res, w, h);
    gl.uniform1f(U.time, time);
    gl.uniform1f(U.zoom, zoom);
    gl.uniform1f(U.inc, inc);
    gl.uniform1f(U.seed, uSeedVal);
    gl.uniform2f(U.pan, panX, panY);
    gl.uniform1f(U.speed, speed);
    gl.uniform1f(U.anom, anomOn ? 1.0 : 0.0);
    gl.uniform1f(U.cine, cineOn ? 1.0 : 0.0);

    gl.uniform1f(U.rs, rs);
    gl.uniform1f(U.diskI, diskI);
    gl.uniform1f(U.rout, routMul);
    gl.uniform1f(U.thick, thick);
    gl.uniform1f(U.sparkAmt, sparkAmt);
    gl.uniform1f(U.sparksOn, sparksOn ? 1.0 : 0.0);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // Mips for bloom
    gl.bindTexture(gl.TEXTURE_2D, sceneTex);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);

    // ----- PASS 2: post to screen -----
    gl.viewport(0,0,w,h);
    gl.disable(gl.BLEND);
    gl.useProgram(progPost);
    gl.bindVertexArray(quad);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, sceneTex);
    gl.uniform1i(P.scene, 0);

    gl.uniform2f(P.res, w, h);
    gl.uniform1f(P.time, time);
    gl.uniform1f(P.bloom, bloomAmt);
    gl.uniform1f(P.cine, cineOn ? 1.0 : 0.0);
    gl.uniform1f(P.zoom, zoom);
    gl.uniform2f(P.pan, panX, panY);
    gl.uniform1f(P.rs, rs);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindVertexArray(null);
  }

  step();

  // ---------- UI / hotkeys ----------
  toggleUI.addEventListener('click', () => {
    const hidden = ui.style.display === 'none';
    ui.style.display = hidden ? '' : 'none';
    toggleUI.textContent = hidden ? 'Hide UI' : 'Show UI';
  });

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if(e.code === 'Space'){
      e.preventDefault();
      paused = !paused;
      playBtn.textContent = paused ? 'Play' : 'Pause';
    }
    if(k === 'r') resetView();
    if(k === 'f') focusHorizon();
    if(k === 'h') toggleUI.click();
  });
})();
</script>
</body>
</html>
