<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Cinematic Black Hole</title>
  <style>
    :root{ color-scheme: dark; }
    html,body{ height:100%; margin:0; background:#02020a; overflow:hidden;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    #c{ position:fixed; inset:0; width:100%; height:100%; display:block; }

    #ui{
      position:fixed; left:12px; top:12px; z-index:5;
      display:flex; flex-direction:column; gap:10px;
      padding:10px 10px 12px;
      border-radius:14px;
      background:rgba(7,7,16,.58);
      border:1px solid rgba(255,255,255,.08);
      box-shadow:0 10px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      user-select:none;
      max-width:min(620px, calc(100vw - 24px));
    }
    #ui .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    #ui .row.tight{ gap:6px; }
    #ui h1{ margin:0; font-size:12px; letter-spacing:.14em; text-transform:uppercase; opacity:.88; }
    button{
      appearance:none; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:8px 10px; border-radius:12px;
      font-weight:600; font-size:12px;
      cursor:pointer;
    }
    button:hover{ background:rgba(255,255,255,.09); }
    button:active{ transform: translateY(1px); }
    label{ font-size:12px; opacity:.92; display:flex; align-items:center; gap:8px; }
    input[type="range"]{ width:180px; }
    select{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:8px 10px; border-radius:12px; font-weight:600; font-size:12px;
    }
    .pill{ padding:6px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05); font-size:12px; opacity:.92; }
    .muted{ opacity:.65; }
    #help{ font-size:12px; opacity:.72; line-height:1.35; }
    #toggleUI{ position:fixed; right:12px; top:12px; z-index:6; }
    @media (max-width:480px){ input[type="range"]{ width:150px; } }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <button id="toggleUI" class="pill">Hide UI</button>
  <div id="ui">
    <h1>Cinematic Black Hole</h1>

    <div class="row">
      <button id="play">Pause</button>
      <button id="focus">Focus horizon</button>
      <button id="reset">Reset view</button>
      <button id="random">New seed</button>
      <button id="copy">Copy link</button>
      <button id="shot">Snapshot 2×</button>
      <span class="pill" id="fps">— fps</span>
    </div>

    <div class="row">
      <label class="muted">Preset
        <select id="preset">
          <option value="golden" selected>Golden</option>
          <option value="interstellar">Interstellar</option>
          <option value="cold">Cold</option>
          <option value="minimal">Minimal</option>
        </select>
      </label>
      <span class="pill muted" id="seedTag">seed=—</span>
    </div>

    <div class="row tight">
      <label><input id="anom" type="checkbox" checked /> Horizon anomalies</label>
      <label><input id="sparks" type="checkbox" checked /> Horizon sparks</label>
      <label><input id="cine" type="checkbox" /> Cinematic</label>
      <label><input id="drift" type="checkbox" checked /> Drift</label>
      <label><input id="autoexp" type="checkbox" checked /> Auto exposure</label>
    </div>

    <div class="row">
      <label>Zoom <input id="zoom" type="range" min="0.55" max="18" step="0.01" value="1.40" /> <span class="pill" id="zoomV">1.40×</span></label>
      <label>Inclination <input id="inc" type="range" min="0" max="82" step="1" value="68" /> <span class="pill" id="incV">68°</span></label>
    </div>

    <div class="row">
      <label>Mass <input id="mass" type="range" min="0.14" max="0.34" step="0.001" value="0.22" /> <span class="pill" id="massV">0.220</span></label>
      <label>Disk intensity <input id="diskI" type="range" min="0" max="2.8" step="0.01" value="1.05" /> <span class="pill" id="diskIV">1.05</span></label>
    </div>

    <div class="row">
      <label>Disk radius <input id="diskR" type="range" min="4.5" max="10.5" step="0.01" value="6.90" /> <span class="pill" id="diskRV">6.90</span></label>
      <label>Disk thickness <input id="thick" type="range" min="0.04" max="0.18" step="0.001" value="0.078" /> <span class="pill" id="thickV">0.078</span></label>
    </div>

    <div class="row">
      <label>Sparks <input id="sparkAmt" type="range" min="0" max="2.2" step="0.01" value="1.00" /> <span class="pill" id="sparkV">1.00</span></label>
      <label>Bloom <input id="bloom" type="range" min="0" max="2.6" step="0.01" value="1.25" /> <span class="pill" id="bloomV">1.25</span></label>
    </div>

    <div class="row">
      <label>Halation <input id="hala" type="range" min="0" max="2.0" step="0.01" value="0.75" /> <span class="pill" id="halaV">0.75</span></label>
      <label>Speed <input id="speed" type="range" min="0" max="1.8" step="0.01" value="1.00" /> <span class="pill" id="speedV">1.00</span></label>
      <label class="muted">Quality
        <select id="q">
          <option value="1">Ultra</option>
          <option value="0.75" selected>High</option>
          <option value="0.55">Balanced</option>
          <option value="0.4">Performance</option>
        </select>
      </label>
    </div>

    <div id="help" class="muted">
      Drag to pan · wheel/trackpad to zoom · Space=pause · H=toggle UI · F=focus · Copy link shares your exact scene
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ---------- tiny utils ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now()*0.001;

  function xmur3(str){
    let h=1779033703^str.length;
    for(let i=0;i<str.length;i++){
      h=Math.imul(h^str.charCodeAt(i),3432918353);
      h=(h<<13)|(h>>>19);
    }
    return function(){
      h=Math.imul(h^(h>>>16),2246822507);
      h=Math.imul(h^(h>>>13),3266489909);
      return (h^=h>>>16)>>>0;
    };
  }

  function parseHash(){
    const raw = location.hash.replace(/^#/, '');
    return new URLSearchParams(raw);
  }

  function writeHash(params){
    history.replaceState(null,'', '#'+params.toString());
  }

  function fmt(n, d=2){ return Number(n).toFixed(d); }

  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ui = document.getElementById('ui');
  const toggleUI = document.getElementById('toggleUI');

  const playBtn = document.getElementById('play');
  const focusBtn = document.getElementById('focus');
  const resetBtn = document.getElementById('reset');
  const randomBtn = document.getElementById('random');
  const copyBtn = document.getElementById('copy');
  const shotBtn = document.getElementById('shot');
  const fpsEl = document.getElementById('fps');
  const presetEl = document.getElementById('preset');
  const seedTag = document.getElementById('seedTag');

  const zoomEl = document.getElementById('zoom');
  const zoomV = document.getElementById('zoomV');
  const incEl = document.getElementById('inc');
  const incV = document.getElementById('incV');
  const bloomEl = document.getElementById('bloom');
  const bloomV = document.getElementById('bloomV');
  const halaEl = document.getElementById('hala');
  const halaV = document.getElementById('halaV');
  const speedEl = document.getElementById('speed');
  const speedV = document.getElementById('speedV');
  const qEl = document.getElementById('q');

  const massEl = document.getElementById('mass');
  const massV = document.getElementById('massV');
  const diskIEl = document.getElementById('diskI');
  const diskIV = document.getElementById('diskIV');
  const diskREl = document.getElementById('diskR');
  const diskRV = document.getElementById('diskRV');
  const thickEl = document.getElementById('thick');
  const thickV = document.getElementById('thickV');
  const sparkAmtEl = document.getElementById('sparkAmt');
  const sparkV = document.getElementById('sparkV');

  const anomEl = document.getElementById('anom');
  const sparksEl = document.getElementById('sparks');
  const cineEl = document.getElementById('cine');
  const driftEl = document.getElementById('drift');
  const autoExpEl = document.getElementById('autoexp');

  console.assert(canvas && ui && toggleUI, 'SelfTest: core DOM nodes missing');

  // ---------- state ----------
  // NOTE: px/py and grade settings are not shown in UI, but are included in the hash so presets feel distinct and shareable.
  const defaults = {
    preset: 'golden',
    seed: String(Math.floor(Math.random()*1e9)),

    // view
    zoom: 1.40,
    inc: 68,
    px: 0.0,
    py: 0.0,

    // physics-ish
    mass: 0.22,

    // disk
    diskI: 1.05,
    diskR: 6.90,
    thick: 0.078,

    // effects
    sparkAmt: 1.00,
    bloom: 1.25,
    hala: 0.75,
    speed: 1.00,
    q: 0.75,

    // toggles
    anom: 1,
    sparks: 1,
    cine: 0,
    drift: 1,
    autoexp: 1,

    // hidden grading (presets use these so they look obviously different)
    gradeR: 1.10,
    gradeG: 1.02,
    gradeB: 0.92,
    sat: 1.08,
    contrast: 1.10,
  };

  // Presets are intentionally more different now: they change camera (zoom + recentre), brightness (autoexp), and grade.
  const presets = {
    golden: {$1anom: 1, sparks: 1, cine: 0, drift: 1, autoexp: 1,
      gradeR: 1.18, gradeG: 1.05, gradeB: 0.86, sat: 1.10, contrast: 1.12,
    },
    interstellar: {
      zoom: 1.85, inc: 74, mass: 0.245,
      diskI: 1.35, diskR: 7.7, thick: 0.068,
      sparkAmt: 0.85, bloom: 1.55, hala: 1.18,
      speed: 0.95, q: 0.75,
      anom: 1, sparks: 1, cine: 1, drift: 1, autoexp: 1,
      gradeR: 1.08, gradeG: 1.06, gradeB: 1.16, sat: 1.14, contrast: 1.16,
    },
    cold: {
      zoom: 1.55, inc: 70, mass: 0.205,
      diskI: 0.95, diskR: 6.35, thick: 0.074,
      sparkAmt: 0.55, bloom: 0.95, hala: 0.40,
      speed: 1.05, q: 0.75,
      anom: 1, sparks: 1, cine: 1, drift: 1, autoexp: 0,
      gradeR: 0.92, gradeG: 1.00, gradeB: 1.26, sat: 1.02, contrast: 1.10,
    },
    minimal: {
      zoom: 1.25, inc: 52, mass: 0.20,
      diskI: 0.75, diskR: 6.25, thick: 0.092,
      sparkAmt: 0.00, bloom: 0.35, hala: 0.05,
      speed: 1.00, q: 0.75,
      anom: 0, sparks: 0, cine: 0, drift: 0, autoexp: 0,
      gradeR: 1.00, gradeG: 1.00, gradeB: 1.00, sat: 0.86, contrast: 1.06,
    }
  };

  const state = { ...defaults };

  // SelfTest: presets integrity and difference (warn if accidentally too similar)
  console.assert(Object.keys(presets).length >= 4, 'SelfTest: expected at least 4 presets');
  console.assert(!!presets.golden && !!presets.interstellar, 'SelfTest: missing required presets');
  (function selfTestPresetDelta(){
    const g = presets.golden;
    const names = Object.keys(presets);
    for(const n of names){
      if(n === 'golden') continue;
      const p = presets[n];
      const dz = Math.abs((p.zoom ?? g.zoom) - g.zoom);
      const di = Math.abs((p.inc ?? g.inc) - g.inc);
      const dg = Math.abs((p.gradeB ?? g.gradeB) - g.gradeB) + Math.abs((p.gradeR ?? g.gradeR) - g.gradeR);
      console.assert(dz > 0.10 || di > 3 || dg > 0.10, `SelfTest: preset '${n}' may be too similar to golden`);
    }
  })();

  function coerce01(v){
    if(v === '0' || v === 0) return 0;
    return 1;
  }

  function loadFromHash(){
    const p = parseHash();
    if(p.get('seed')) state.seed = p.get('seed');
    if(p.get('preset')) state.preset = p.get('preset');

    const num = (k, min, max) => {
      if(!p.has(k)) return;
      const v = parseFloat(p.get(k));
      if(Number.isFinite(v)) state[k] = clamp(v, min, max);
    };
    const int = (k, min, max) => {
      if(!p.has(k)) return;
      const v = parseInt(p.get(k), 10);
      if(Number.isFinite(v)) state[k] = clamp(v, min, max);
    };
    const flag = (k) => { if(p.has(k)) state[k] = coerce01(p.get(k)); };

    num('zoom', 0.55, 18);
    int('inc', 0, 82);
    num('px', -6.0, 6.0);
    num('py', -6.0, 6.0);

    num('mass', 0.14, 0.34);
    num('diskI', 0, 2.8);
    num('diskR', 4.5, 10.5);
    num('thick', 0.04, 0.18);

    num('sparkAmt', 0, 2.2);
    num('bloom', 0, 2.6);
    num('hala', 0, 2.0);
    num('speed', 0, 1.8);
    num('q', 0.35, 1.0);

    // hidden grading
    num('gr', 0.70, 1.40); // gradeR
    num('gg', 0.70, 1.40); // gradeG
    num('gb', 0.70, 1.60); // gradeB
    num('sat', 0.65, 1.40);
    num('con', 0.85, 1.35);

    // map grade short keys to state
    if(p.has('gr')) state.gradeR = clamp(parseFloat(p.get('gr')), 0.70, 1.40);
    if(p.has('gg')) state.gradeG = clamp(parseFloat(p.get('gg')), 0.70, 1.40);
    if(p.has('gb')) state.gradeB = clamp(parseFloat(p.get('gb')), 0.70, 1.60);

    flag('anom');
    flag('sparks');
    flag('cine');
    flag('drift');
    flag('autoexp');

    if(!presets[state.preset]) state.preset = 'golden';
  }

  function applyStateToUI(){
    presetEl.value = state.preset;
    seedTag.textContent = `seed=${state.seed}`;

    zoomEl.value = state.zoom;
    incEl.value = state.inc;

    massEl.value = state.mass;
    diskIEl.value = state.diskI;
    diskREl.value = state.diskR;
    thickEl.value = state.thick;

    sparkAmtEl.value = state.sparkAmt;
    bloomEl.value = state.bloom;
    halaEl.value = state.hala;
    speedEl.value = state.speed;
    qEl.value = String(state.q);

    anomEl.checked = !!state.anom;
    sparksEl.checked = !!state.sparks;
    cineEl.checked = !!state.cine;
    driftEl.checked = !!state.drift;
    autoExpEl.checked = !!state.autoexp;

    zoomV.textContent = `${fmt(state.zoom,2)}×`;
    incV.textContent = `${Math.round(state.inc)}°`;
    massV.textContent = fmt(state.mass,3);
    diskIV.textContent = fmt(state.diskI,2);
    diskRV.textContent = fmt(state.diskR,2);
    thickV.textContent = fmt(state.thick,3);
    sparkV.textContent = fmt(state.sparkAmt,2);
    bloomV.textContent = fmt(state.bloom,2);
    halaV.textContent = fmt(state.hala,2);
    speedV.textContent = fmt(state.speed,2);
  }

  let hashTimer = 0;
  function scheduleHashWrite(){
    clearTimeout(hashTimer);
    hashTimer = setTimeout(() => {
      const p = new URLSearchParams();
      p.set('preset', state.preset);
      p.set('seed', state.seed);

      p.set('zoom', fmt(state.zoom,2));
      p.set('inc', String(Math.round(state.inc)));
      p.set('px', fmt(state.px,3));
      p.set('py', fmt(state.py,3));

      p.set('mass', fmt(state.mass,3));
      p.set('diskI', fmt(state.diskI,2));
      p.set('diskR', fmt(state.diskR,2));
      p.set('thick', fmt(state.thick,3));

      p.set('sparkAmt', fmt(state.sparkAmt,2));
      p.set('bloom', fmt(state.bloom,2));
      p.set('hala', fmt(state.hala,2));
      p.set('speed', fmt(state.speed,2));
      p.set('q', fmt(state.q,2));

      // hidden grading
      p.set('gr', fmt(state.gradeR,3));
      p.set('gg', fmt(state.gradeG,3));
      p.set('gb', fmt(state.gradeB,3));
      p.set('sat', fmt(state.sat,3));
      p.set('con', fmt(state.contrast,3));

      p.set('anom', state.anom ? '1' : '0');
      p.set('sparks', state.sparks ? '1' : '0');
      p.set('cine', state.cine ? '1' : '0');
      p.set('drift', state.drift ? '1' : '0');
      p.set('autoexp', state.autoexp ? '1' : '0');

      writeHash(p);
    }, 120);
  }

  // ---------- Seed ----------
  let uSeedVal = 0.0;
  function rebuildSeed(){
    const h = xmur3(state.seed);
    const a = h();
    const b = h();
    uSeedVal = (a/4294967296)*1000.0 + (b/4294967296)*0.001;
    console.assert(Number.isFinite(uSeedVal), 'SelfTest: uSeedVal should be finite');
  }

  function setSeed(str){
    state.seed = String(str || '').trim() || String(Math.floor(Math.random()*1e9));
    seedTag.textContent = `seed=${state.seed}`;
    scheduleHashWrite();
    rebuildSeed();
  }

  function applyPreset(name){
    if(!presets[name]) return;
    state.preset = name;
    const o = presets[name];
    for(const k of Object.keys(o)) state[k] = o[k];

    // Make the change visibly noticeable:
    // - recenter view (since copy link now includes pan)
    state.px = 0.0;
    state.py = 0.0;

    applyStateToUI();
    scheduleHashWrite();
  }

  // ---------- init from hash ----------
  loadFromHash();
  if(!presets[state.preset]) state.preset = 'golden';
  rebuildSeed();
  applyStateToUI();

  // SelfTest: hash roundtrip basic
  (function selfTestHash(){
    const p = new URLSearchParams();
    p.set('preset','golden');
    p.set('seed','123');
    p.set('px','0.125');
    p.set('py','-0.250');
    writeHash(p);
    const r = parseHash();
    console.assert(r.get('preset') === 'golden' && r.get('seed') === '123', 'SelfTest: hash read/write failed');
    console.assert(r.get('px') === '0.125' && r.get('py') === '-0.250', 'SelfTest: hash pan keys missing');
    // restore current state hash
    scheduleHashWrite();
  })();

  // Smooth transitions so preset switching feels cinematic and obvious.
  const LIVE_KEYS = [
    'zoom','inc','px','py',
    'mass','diskI','diskR','thick',
    'sparkAmt','bloom','hala','speed',
    'anom','sparks','cine','drift','autoexp',
    'gradeR','gradeG','gradeB','sat','contrast'
  ];
  const live = {};
  for(const k of LIVE_KEYS) live[k] = state[k];

  // ---------- UI events ----------
  let paused = false;

  const toggleUIFn = () => {
    const hidden = ui.style.display === 'none';
    ui.style.display = hidden ? '' : 'none';
    toggleUI.textContent = hidden ? 'Hide UI' : 'Show UI';
  };
  toggleUI.addEventListener('click', toggleUIFn);

  playBtn.addEventListener('click', () => {
    paused = !paused;
    playBtn.textContent = paused ? 'Play' : 'Pause';
  });

  function resetView(){
    const keepSeed = state.seed;
    Object.assign(state, defaults);
    state.seed = keepSeed;
    state.preset = 'golden';
    applyStateToUI();
    scheduleHashWrite();
  }

  function focusHorizon(){
    state.zoom = 10.5;
    applyStateToUI();
    scheduleHashWrite();
  }

  resetBtn.addEventListener('click', resetView);
  focusBtn.addEventListener('click', focusHorizon);
  randomBtn.addEventListener('click', () => setSeed(String(Math.floor(Math.random()*1e9))));
  presetEl.addEventListener('change', () => applyPreset(presetEl.value));

  function bindRange(el, key, min, max){
    el.addEventListener('input', () => {
      const v = clamp(parseFloat(el.value), min, max);
      state[key] = v;
      applyStateToUI();
      scheduleHashWrite();
      if(key === 'q') resize();
    });
  }

  bindRange(zoomEl, 'zoom', 0.55, 18);
  bindRange(incEl, 'inc', 0, 82);
  bindRange(massEl, 'mass', 0.14, 0.34);
  bindRange(diskIEl, 'diskI', 0, 2.8);
  bindRange(diskREl, 'diskR', 4.5, 10.5);
  bindRange(thickEl, 'thick', 0.04, 0.18);
  bindRange(sparkAmtEl, 'sparkAmt', 0, 2.2);
  bindRange(bloomEl, 'bloom', 0, 2.6);
  bindRange(halaEl, 'hala', 0, 2.0);
  bindRange(speedEl, 'speed', 0, 1.8);
  qEl.addEventListener('change', () => {
    state.q = clamp(parseFloat(qEl.value), 0.35, 1.0);
    applyStateToUI();
    scheduleHashWrite();
    resize();
  });

  function bindFlag(el, key){
    el.addEventListener('change', () => {
      state[key] = el.checked ? 1 : 0;
      scheduleHashWrite();
    });
  }

  bindFlag(anomEl, 'anom');
  bindFlag(sparksEl, 'sparks');
  bindFlag(cineEl, 'cine');
  bindFlag(driftEl, 'drift');
  bindFlag(autoExpEl, 'autoexp');

  copyBtn.addEventListener('click', async () => {
    scheduleHashWrite();
    const url = location.href;
    try{
      await navigator.clipboard.writeText(url);
      copyBtn.textContent = 'Copied!';
      setTimeout(()=>copyBtn.textContent='Copy link', 800);
    }catch{
      prompt('Copy this link:', url);
    }
  });

  // Scroll / pinch zoom
  window.addEventListener('wheel', (e) => {
    e.preventDefault();
    const dir = Math.sign(e.deltaY);
    const factor = Math.exp(-dir * 0.08);
    state.zoom = clamp(state.zoom * factor, parseFloat(zoomEl.min), parseFloat(zoomEl.max));
    applyStateToUI();
    scheduleHashWrite();
  }, { passive:false });

  // Hotkeys
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if(e.code === 'Space'){
      e.preventDefault();
      paused = !paused;
      playBtn.textContent = paused ? 'Play' : 'Pause';
    }
    if(k === 'r') resetView();
    if(k === 'f') focusHorizon();
    if(k === 'h') toggleUIFn();
  });

  // ---------- WebGL2 setup ----------
  const gl = canvas.getContext('webgl2', { antialias:false, alpha:false, depth:false, stencil:false, preserveDrawingBuffer:false });
  if(!gl){
    document.body.innerHTML = '<div style="padding:18px;color:#fff;font-family:system-ui">WebGL2 not supported in this browser.</div>';
    return;
  }

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      const msg = gl.getShaderInfoLog(sh) || 'Shader compile error';
      console.error(msg, src);
      throw new Error(msg);
    }
    return sh;
  }
  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      const msg = gl.getProgramInfoLog(p) || 'Program link error';
      console.error(msg);
      throw new Error(msg);
    }
    return p;
  }

  const quadVS = `#version 300 es
    precision highp float;
    layout(location=0) in vec2 aPos;
    out vec2 vUv;
    void main(){
      vUv = aPos*0.5 + 0.5;
      gl_Position = vec4(aPos, 0.0, 1.0);
    }
  `;

  // ----- Main scene (linear color; post handles tonemap/bloom) -----
  const bhFS = `#version 300 es
    precision highp float;
    out vec4 frag;
    in vec2 vUv;

    uniform vec2 uRes;
    uniform float uTime;
    uniform float uZoom;
    uniform float uInc;
    uniform float uSeed;
    uniform vec2 uPan;
    uniform float uSpeed;
    uniform float uAnom;
    uniform float uCine;

    uniform float uRs;
    uniform float uDiskI;
    uniform float uRoutMul;
    uniform float uThick;
    uniform float uSparkAmt;
    uniform float uSparksOn;

    float hash12(vec2 p){
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    float noise(vec2 p){
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash12(i);
      float b = hash12(i + vec2(1.0,0.0));
      float c = hash12(i + vec2(0.0,1.0));
      float d = hash12(i + vec2(1.0,1.0));
      vec2 u = f*f*(3.0-2.0*f);
      return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
    }

    float fbm(vec2 p){
      float v = 0.0;
      float a = 0.55;
      mat2 m = mat2(1.7,1.2,-1.2,1.7);
      for(int i=0;i<6;i++){
        v += a*noise(p);
        p = m*p;
        a *= 0.5;
      }
      return v;
    }

    vec2 rot(vec2 p, float a){
      float s = sin(a), c = cos(a);
      return vec2(c*p.x - s*p.y, s*p.x + c*p.y);
    }

    float doppler(float beta, float vlos){
      float denom = max(0.12, 1.0 - beta*vlos);
      return pow(1.0/denom, 3.1);
    }

    float starsAt(vec2 x, float t, float seed){
      float s = 0.0;
      vec2 p = x;
      for(int i=0;i<3;i++){
        float sc = mix(36.0, 92.0, float(i)/2.0);
        vec2 g = floor(p*sc + seed*0.01 + float(i)*17.3);
        float h = hash12(g + seed);
        vec2 f = fract(p*sc);
        vec2 c = f - 0.5;
        float d = dot(c, c);
        float star = smoothstep(0.040, 0.0, d) * smoothstep(0.9968, 1.0, h);
        float tw = 0.65 + 0.35*sin(t*2.0 + h*9.0);
        s += star * tw * (0.70 + 0.45*hash12(g + 9.1));
        p = rot(p, 1.12);
      }
      return s;
    }

    float sparkLayer(vec2 pol, float t, float seed, float gridA, float gridR, float keep, float sharp){
      vec2 g = vec2(pol.x*gridA, pol.y*gridR + t);
      vec2 i = floor(g);
      vec2 f = fract(g);
      float h = hash12(i + seed);
      vec2 off = vec2(hash12(i + seed + 11.7), hash12(i + seed + 27.3));
      vec2 p = 0.5 + (off - 0.5) * 0.65;
      vec2 d = (f - p);
      d.x *= 1.2;
      float dist2 = dot(d,d);
      float s = exp(-dist2 * sharp);
      float tw = 0.55 + 0.45*sin(t*7.0 + h*10.0);
      return s * tw * step(keep, h);
    }

    void main(){
      vec2 p = (vUv*2.0 - 1.0);
      float aspect = uRes.x / uRes.y;
      p.x *= aspect;

      p = p / max(0.001, uZoom) + uPan;

      float rs = uRs;
      float shadow = rs*1.14;
      float photon = rs*1.58;

      float t = uTime * uSpeed;
      float inc = radians(uInc);

      float r = length(p);
      float phi = atan(p.y, p.x);

      float nearH = 1.0 - smoothstep(rs*1.2, rs*5.6, r);
      float anom = uAnom * nearH;

      float def = (rs*rs) / (r*r + 0.004);
      def *= smoothstep(rs*0.95, rs*8.2, r);
      def *= mix(0.86, 1.10, uCine);

      float shimmer = (fbm(p*18.0 + vec2(0.0, t*0.55) + uSeed) - 0.5);
      def *= 1.0 + anom*(0.26*shimmer);

      vec2 lp = rot(p, def);
      lp *= (1.0 + def*0.24);

      vec3 col = vec3(0.0);

      // ----- Background (nebula + lensed star arcs) -----
      float neb1 = fbm(lp*1.2 + vec2(t*0.012, -t*0.010) + uSeed*0.13);
      float neb2 = fbm(lp*2.4 + vec2(-t*0.006, t*0.008) + uSeed*0.31);
      float neb = pow(clamp(0.55*neb1 + 0.45*neb2, 0.0, 1.0), 2.15);

      vec3 nebCol = vec3(0.015,0.020,0.045)
        + 0.22*vec3(0.12,0.22,0.90)*neb
        + 0.08*vec3(0.75,0.20,0.10)*pow(neb2, 3.0);

      float s0 = starsAt(lp*1.35, t, uSeed);

      vec2 tanDir = normalize(vec2(-lp.y, lp.x) + 1e-6);
      float streak = pow(clamp(nearH, 0.0, 1.0), 1.5) * (0.65 + 0.55*uCine);
      float so = 0.025 * (1.0 + 2.5*streak);
      float s1 = starsAt((lp + tanDir*so)*1.35, t, uSeed);
      float s2 = starsAt((lp - tanDir*so)*1.35, t, uSeed);
      float sStar = mix(s0, (s0*0.55 + 0.225*(s1+s2)), clamp(streak, 0.0, 1.0));

      col += nebCol;
      col += vec3(1.25,1.30,1.45) * sStar;

      // ----- Accretion disk (layered / volumetric-ish slab) -----
      vec2 dp = lp;
      float drag = 0.28 * (rs / (r + rs));
      drag *= 1.0 + anom*0.75;
      dp = rot(dp, drag);

      float cI = max(0.16, cos(inc));
      vec2 q = vec2(dp.x, dp.y / cI);
      float dr = length(q);
      float dphi = atan(q.y, q.x);

      float rin = rs*1.22;
      float rout = rs*uRoutMul;

      float thickness = uThick + 0.055*fbm(vec2(dphi*1.6, dr*9.4) + vec2(t*0.62, -t*0.28) + uSeed);
      thickness *= 1.0 + anom*1.0;

      float y = abs(q.y);
      float coreD = exp(-pow(y / (thickness + 1e-4), 1.15));
      float wingD = exp(-pow(y / (thickness*2.2 + 1e-4), 1.85)) * 0.55;
      float dens = clamp(coreD + wingD, 0.0, 1.0);

      float diskMask = dens;
      diskMask *= smoothstep(rin, rin + rs*0.20, dr);
      diskMask *= 1.0 - smoothstep(rout - rs*0.28, rout, dr);

      float lr = log(max(1e-3, dr/rs));
      float shear = sin(dphi*12.0 + lr*7.0 + t*1.20) * 0.5 + 0.5;

      float bands = 0.0;
      bands += 0.5 + 0.5*sin(lr*22.0 + t*0.80 + uSeed*1.7);
      bands += 0.5 + 0.5*sin(lr*38.0 - t*1.05 + uSeed*3.4);
      bands += 0.5 + 0.5*sin(lr*64.0 + t*1.35 + uSeed*5.1);
      bands = (bands/3.0);
      bands = pow(clamp(bands, 0.0, 1.0), 2.2);

      float ringlets = pow(abs(sin(lr*120.0 + t*0.55 + uSeed*2.3)), 18.0);
      ringlets *= smoothstep(rin + rs*0.2, rin + rs*1.6, dr);
      ringlets *= 1.0 - smoothstep(rout - rs*0.6, rout, dr);

      float fil = fbm(vec2(dphi*9.2, dr*12.0) + vec2(t*1.55, -t*0.85) + uSeed*2.1);
      float swirl = fbm(vec2(dr*7.2, dphi*3.4) + vec2(-t*0.40, t*0.62) + uSeed*3.7);
      float arms = sin(dphi*2.0 + t*2.35) * 0.5 + 0.5;

      float structure = 0.40*fil + 0.14*swirl + 0.14*arms + 0.32*shear;
      structure = clamp(structure, 0.0, 1.0);
      float layerDetail = clamp(0.70*bands + 0.55*ringlets, 0.0, 1.0);
      structure = clamp(0.40*structure + 0.98*layerDetail, 0.0, 1.0);
      structure = pow(structure, 1.10);

      float beta = clamp(0.82 * sqrt(rin / max(dr, rin)), 0.0, 0.88);
      float vlos = sin(dphi) * sin(inc);
      float beam = doppler(beta, vlos);
      float gred = sqrt(max(0.0, 1.0 - rs / max(dr, rs*1.02)));

      float side = smoothstep(-0.18, 0.18, vlos);
      vec3 blueTint = vec3(0.70, 0.95, 1.35);
      vec3 redTint  = vec3(1.20, 0.78, 0.40);

      vec3 hot  = mix(vec3(1.95, 1.25, 0.42), vec3(1.45, 1.75, 2.30), uCine);
      vec3 warm = mix(vec3(1.25, 0.68, 0.20), vec3(0.52, 0.92, 1.65), uCine);
      vec3 ember= mix(vec3(0.52, 0.18, 0.06), vec3(0.18, 0.30, 0.58), uCine*0.55);

      float heat = smoothstep(rout, rin, dr);
      vec3 baseCol = mix(ember, warm, pow(heat, 0.82));
      baseCol = mix(baseCol, hot,  pow(heat, 2.75));

      vec3 vTint = mix(redTint, blueTint, side);
      baseCol *= mix(vec3(1.0), vTint, 0.28*uCine);
      baseCol *= mix(0.52, 1.0, gred);

      float layerHi = pow(layerDetail, 1.15);
      float edgeHi = pow(clamp(1.0 - y/(thickness*1.55 + 1e-4), 0.0, 1.0), 3.0);
      float spec = edgeHi * (0.35 + 0.65*layerHi);
      vec3 hiCol = mix(vec3(2.2, 1.6, 0.8), vec3(1.4, 2.1, 2.4), uCine*side);

      vec3 emit = baseCol * (0.45 + 2.05*structure);
      emit += hiCol * (0.25 + 0.65*uCine) * spec;
      emit *= uDiskI;

      float tau = (0.65 + 1.8*heat) * dens * (0.8 + 1.4*nearH);
      float farSide = step(0.0, q.y) * smoothstep(radians(25.0), radians(82.0), inc);
      tau *= mix(1.0, 1.55, farSide);
      float trans = exp(-tau);

      float phase = mix(0.55, 1.10, side) * (0.75 + 0.25*uCine);
      vec3 scatterCol = mix(baseCol, hiCol, 0.40) * phase;

      vec3 diskCol = emit * (1.0 - trans) + scatterCol * (0.20*(1.0-trans));
      diskCol *= diskMask * beam;

      float innerGlow = exp(-pow((dr - rin) / (rs*0.110), 2.0));
      diskCol += innerGlow * mix(vec3(2.2, 1.35, 0.48), vec3(1.4, 2.1, 2.4), uCine) * (0.30 + 0.95*structure) * uDiskI;

      col += diskCol;

      // secondary lensed disk image
      vec2 q2 = q;
      q2.y = -q2.y;
      float dr2 = length(q2);
      float dphi2 = atan(q2.y, q2.x);
      float y2 = abs(q2.y);
      float dens2 = exp(-pow(y2/(thickness*0.95 + 1e-4), 1.25));
      float disk2 = dens2;
      disk2 *= smoothstep(rin, rin + rs*0.20, dr2);
      disk2 *= 1.0 - smoothstep(rout - rs*0.28, rout, dr2);
      float beta2 = clamp(0.80 * sqrt(rin / max(dr2, rin)), 0.0, 0.86);
      float vlos2 = sin(dphi2) * sin(inc);
      float side2 = smoothstep(-0.18, 0.18, vlos2);
      float beam2 = doppler(beta2, vlos2);
      float g2 = sqrt(max(0.0, 1.0 - rs / max(dr2, rs*1.02)));

      float lr2 = log(max(1e-3, dr2/rs));
      float bands2 = 0.0;
      bands2 += 0.5 + 0.5*sin(lr2*26.0 + t*0.78 + uSeed*1.2);
      bands2 += 0.5 + 0.5*sin(lr2*44.0 - t*1.10 + uSeed*2.6);
      bands2 = pow(clamp(bands2*0.5, 0.0, 1.0), 2.0);

      vec3 diskCol2 = mix(ember, warm, pow(smoothstep(rout, rin, dr2), 0.85));
      diskCol2 = mix(diskCol2, hot, pow(smoothstep(rout, rin, dr2), 2.6));
      diskCol2 *= mix(vec3(1.0), mix(redTint, blueTint, side2), 0.28*uCine);
      diskCol2 *= mix(0.55, 1.0, g2);
      diskCol2 *= (0.40 + 1.40*bands2) * beam2 * uDiskI;

      float arcMix = pow(nearH, 2.0) * smoothstep(rs*1.35, rs*0.95, r);
      col += diskCol2 * disk2 * (0.38 + 0.62*arcMix) * arcMix;

      // sparks
      if(uSparksOn > 0.5){
        vec2 pol = vec2(dphi, dr/rs);
        float gate = diskMask;
        gate *= smoothstep(1.08, 1.45, pol.y);
        gate *= 1.0 - smoothstep(3.4, 4.8, pol.y);

        float nh = 1.0 - smoothstep(rs*1.05, rs*2.4, dr);
        float dust = pow(max(0.0, fbm(vec2(dphi*10.0, pol.y*7.5) + vec2(t*0.9, -t*0.4) + uSeed*2.0) - 0.56), 1.7);

        float L1 = sparkLayer(vec2(dphi, pol.y), t*0.75, uSeed*7.1, 18.0, 6.0, 0.93, 56.0);
        float L2 = sparkLayer(vec2(dphi, pol.y), t*1.05, uSeed*9.3, 28.0, 8.5, 0.955, 92.0);
        float L3 = sparkLayer(vec2(dphi, pol.y), t*0.55, uSeed*4.9, 12.0, 5.0, 0.90, 42.0);

        float sparks = (L1*0.65 + L2*0.85 + L3*0.45);
        sparks += dust * (0.45 + 0.55*nh);

        float edge = smoothstep(shadow + rs*0.08, shadow - rs*0.02, r);
        sparks *= gate * (1.0 - edge);

        vec3 sparkCol = mix(vec3(2.0, 1.55, 0.75), vec3(0.95, 1.55, 2.25), uCine*side);
        col += sparks * sparkCol * uSparkAmt;
      }

      // photon ring + micro-caustics
      float ring = exp(-pow((r - photon) / (rs*0.082), 2.0));
      float micro = 0.5 + 0.5*sin(phi*120.0 + fbm(vec2(phi*12.0, r*28.0) + uSeed)*9.0 + t*0.6);
      micro = pow(micro, 2.2);
      ring *= 0.55 + 0.45*micro;

      vec3 ringCol = mix(vec3(1.55, 1.20, 0.65), vec3(0.78, 1.10, 1.95), uCine);
      ringCol *= mix(vec3(1.05,0.95,0.90), vec3(0.85,1.05,1.35), side*uCine);
      col += ring * ringCol * (1.0 + 0.45*uCine);

      float edge = smoothstep(shadow + rs*0.08, shadow - rs*0.02, r);
      col *= 1.0 - 0.94*edge;

      float core = smoothstep(rs*1.02, rs*0.98, r);
      col = mix(col, vec3(0.0), core);

      float halo = exp(-pow((r - shadow) / (rs*0.16), 2.0));
      float haloFine = fbm(vec2(phi*3.0, r*14.0) + vec2(t*0.3, -t*0.22) + uSeed*0.3);
      col += halo * mix(vec3(0.24, 0.19, 0.14), vec3(0.14, 0.22, 0.36), uCine) * (0.5 + 0.5*haloFine) * (0.85 + 0.65*uCine);

      float vig = smoothstep(1.50, 0.22, length((vUv-0.5)*vec2(aspect,1.0)));
      col *= 0.70 + 0.30*vig;

      col = min(col, vec3(12.0));
      frag = vec4(col, 1.0);
    }
  `;

  // ----- Post (bloom + halation + auto exposure + dispersion + grade) -----
  const postFS = `#version 300 es
    precision highp float;
    out vec4 frag;
    in vec2 vUv;

    uniform sampler2D uScene;
    uniform vec2 uRes;
    uniform float uTime;
    uniform float uBloom;
    uniform float uHalation;
    uniform float uCine;
    uniform float uAutoExp;

    uniform float uZoom;
    uniform vec2 uPan;
    uniform float uRs;

    uniform vec3 uGrade;
    uniform float uSat;
    uniform float uContrast;

    float hash12(vec2 p){
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    vec3 tonemapFilmic(vec3 x){
      x = max(x, 0.0);
      x = (x*(2.20*x + 0.05)) / (x*(2.20*x + 1.20) + 0.05);
      return x;
    }

    void main(){
      vec2 uv = vUv;

      float aspect = uRes.x / uRes.y;
      vec2 p = (uv*2.0 - 1.0);
      p.x *= aspect;
      p = p / max(0.001, uZoom) + uPan;
      float shadow = uRs*1.14;
      float pr = length(p);

      float lensF = smoothstep(shadow*5.5, shadow*1.3, pr) * uCine;
      float ca = (0.0007 + 0.0022*lensF);
      vec2 d = (uv - 0.5);
      vec2 o = d * (0.65 + 0.35*length(d)) * ca;

      vec3 base;
      base.r = texture(uScene, uv + o).r;
      base.g = texture(uScene, uv).g;
      base.b = texture(uScene, uv - o).b;

      // auto exposure (cheap average via center mip)
      float lod = clamp(log2(max(2.0, min(uRes.x, uRes.y))) - 4.0, 3.0, 8.0);
      vec3 avg = textureLod(uScene, vec2(0.5), lod).rgb;
      float lum = max(1e-4, dot(avg, vec3(0.2126,0.7152,0.0722)));
      float exposure = clamp(0.55 / lum, 0.65, 2.15);
      base *= mix(1.0, exposure, uAutoExp);

      // bloom from lower mips
      vec3 b2 = textureLod(uScene, uv, 2.0).rgb;
      vec3 b3 = textureLod(uScene, uv, 3.2).rgb;
      vec3 b4 = textureLod(uScene, uv, 4.4).rgb;
      vec3 bloom = (b2*0.85 + b3*0.55 + b4*0.35);
      bloom = max(bloom - 0.10, 0.0);
      base += bloom * (0.70 * uBloom);

      // halation
      vec2 px = 1.0 / uRes;
      vec3 h = vec3(0.0);
      h += texture(uScene, uv + px*vec2( 2.0, 0.0)).rgb;
      h += texture(uScene, uv + px*vec2(-2.0, 0.0)).rgb;
      h += texture(uScene, uv + px*vec2( 0.0, 2.0)).rgb;
      h += texture(uScene, uv + px*vec2( 0.0,-2.0)).rgb;
      h *= 0.25;
      float hl = max(0.0, dot(h, vec3(0.2126,0.7152,0.0722)) - 0.06);
      vec3 warm = vec3(1.25, 0.85, 0.45);
      base += warm * hl * (0.25*uHalation) * (0.55 + 0.45*uCine);

      // vignette
      float v = smoothstep(0.95, 0.25, length((uv-0.5)*vec2(aspect,1.0)));
      base *= mix(0.82, 1.0, v);

      // film grain
      float g = hash12(uv*uRes + vec2(uTime*120.0, uTime*37.0));
      float grain = (g - 0.5) * 0.06 * uCine;
      base *= 1.0 + grain;

      float grit = pow(hash12(uv*uRes*0.35 + uTime*9.0), 18.0) * uCine;
      base += grit * 0.10;

      // grade (makes presets obviously different)
      base *= uGrade;
      float L = dot(base, vec3(0.2126,0.7152,0.0722));
      base = mix(vec3(L), base, uSat);
      // contrast around middle grey (0.18)
      base = (base - 0.18) * uContrast + 0.18;
      base = max(base, 0.0);

      // Hard mask the black hole shadow so it stays perfectly black
      float hole = smoothstep(shadow*1.01, shadow*0.98, pr);
      base *= (1.0 - hole);

      vec3 outc = tonemapFilmic(base);
      outc = pow(outc, vec3(1.0/2.2));
      frag = vec4(outc, 1.0);
    }
  `;

  const progBH = link(compile(gl.VERTEX_SHADER, quadVS), compile(gl.FRAGMENT_SHADER, bhFS));
  const progPost = link(compile(gl.VERTEX_SHADER, quadVS), compile(gl.FRAGMENT_SHADER, postFS));

  // Fullscreen quad
  const quad = gl.createVertexArray();
  gl.bindVertexArray(quad);
  const qb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, qb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1,  -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
  gl.bindVertexArray(null);

  // Uniforms (scene)
  const U = {
    res: gl.getUniformLocation(progBH, 'uRes'),
    time: gl.getUniformLocation(progBH, 'uTime'),
    zoom: gl.getUniformLocation(progBH, 'uZoom'),
    inc: gl.getUniformLocation(progBH, 'uInc'),
    seed: gl.getUniformLocation(progBH, 'uSeed'),
    pan: gl.getUniformLocation(progBH, 'uPan'),
    speed: gl.getUniformLocation(progBH, 'uSpeed'),
    anom: gl.getUniformLocation(progBH, 'uAnom'),
    cine: gl.getUniformLocation(progBH, 'uCine'),

    rs: gl.getUniformLocation(progBH, 'uRs'),
    diskI: gl.getUniformLocation(progBH, 'uDiskI'),
    rout: gl.getUniformLocation(progBH, 'uRoutMul'),
    thick: gl.getUniformLocation(progBH, 'uThick'),
    sparkAmt: gl.getUniformLocation(progBH, 'uSparkAmt'),
    sparksOn: gl.getUniformLocation(progBH, 'uSparksOn'),
  };

  // Uniforms (post)
  const P = {
    res: gl.getUniformLocation(progPost, 'uRes'),
    time: gl.getUniformLocation(progPost, 'uTime'),
    bloom: gl.getUniformLocation(progPost, 'uBloom'),
    hala: gl.getUniformLocation(progPost, 'uHalation'),
    cine: gl.getUniformLocation(progPost, 'uCine'),
    autoexp: gl.getUniformLocation(progPost, 'uAutoExp'),
    zoom: gl.getUniformLocation(progPost, 'uZoom'),
    pan: gl.getUniformLocation(progPost, 'uPan'),
    rs: gl.getUniformLocation(progPost, 'uRs'),
    scene: gl.getUniformLocation(progPost, 'uScene'),

    grade: gl.getUniformLocation(progPost, 'uGrade'),
    sat: gl.getUniformLocation(progPost, 'uSat'),
    contrast: gl.getUniformLocation(progPost, 'uContrast'),
  };

  // ---------- render targets ----------
  let w=0, h=0, dpr=1, cssW=0, cssH=0;
  let q = state.q;

  let sceneTex=null, sceneFBO=null;
  let useFloat=false;
  const extFloat = gl.getExtension('EXT_color_buffer_float');
  useFloat = !!extFloat;

  function createTexture(w, h, mipmap){
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);

    const internalFormat = useFloat ? gl.RGBA16F : gl.RGBA8;
    const type = useFloat ? gl.HALF_FLOAT : gl.UNSIGNED_BYTE;

    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, gl.RGBA, type, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);

    gl.bindTexture(gl.TEXTURE_2D, null);
    return tex;
  }

  function createFBO(tex){
    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return fbo;
  }

  function createSceneTarget(){
    if(sceneTex) gl.deleteTexture(sceneTex);
    if(sceneFBO) gl.deleteFramebuffer(sceneFBO);
    sceneTex = createTexture(w, h, true);
    sceneFBO = createFBO(sceneTex);

    gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO);
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    if(status !== gl.FRAMEBUFFER_COMPLETE){
      if(useFloat){
        useFloat = false;
        if(sceneTex) gl.deleteTexture(sceneTex);
        if(sceneFBO) gl.deleteFramebuffer(sceneFBO);
        sceneTex = createTexture(w, h, true);
        sceneFBO = createFBO(sceneTex);
      }
    }
  }

  function resize(){
    cssW = Math.max(1, Math.floor(window.innerWidth));
    cssH = Math.max(1, Math.floor(window.innerHeight));
    dpr = Math.min(2.0, window.devicePixelRatio || 1);
    q = clamp(state.q, 0.35, 1.0);

    w = Math.max(2, Math.floor(cssW * dpr * q));
    h = Math.max(2, Math.floor(cssH * dpr * q));
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';

    gl.viewport(0,0,w,h);
    createSceneTarget();
  }

  window.addEventListener('resize', resize);
  resize();

  // ---------- camera controls (pan) ----------
  let drag = false;
  let lastX = 0, lastY = 0;

  function pointerPos(ev){
    const rect = canvas.getBoundingClientRect();
    return { x: (ev.clientX - rect.left), y: (ev.clientY - rect.top) };
  }

  canvas.addEventListener('pointerdown', (e) => {
    drag = true;
    canvas.setPointerCapture(e.pointerId);
    const p = pointerPos(e);
    lastX = p.x; lastY = p.y;
  });
  canvas.addEventListener('pointerup', () => { drag = false; });
  canvas.addEventListener('pointercancel', () => { drag = false; });
  canvas.addEventListener('pointermove', (e) => {
    if(!drag) return;
    if(w <= 2 || h <= 2) return;

    const p = pointerPos(e);
    const dx = p.x - lastX;
    const dy = p.y - lastY;
    lastX = p.x; lastY = p.y;

    const aspect = w / h;
    const sx = (dx / w) * 2.0 * aspect;
    const sy = (dy / h) * 2.0;
    state.px -= sx / Math.max(0.001, state.zoom);
    state.py += sy / Math.max(0.001, state.zoom);
    scheduleHashWrite();
  });

  // ---------- snapshot (2x) ----------
  async function snapshot(scale){
    const snap = {};
    for(const k of LIVE_KEYS) snap[k] = live[k];

    const maxSide = 4096;
    const outW = Math.min(maxSide, Math.max(2, Math.floor(cssW * scale)));
    const outH = Math.min(maxSide, Math.max(2, Math.floor(cssH * scale)));

    const tmpSceneTex = createTexture(outW, outH, true);
    const tmpSceneFBO = createFBO(tmpSceneTex);

    const tmpOutTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tmpOutTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, outW, outH, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.bindTexture(gl.TEXTURE_2D, null);
    const tmpOutFBO = createFBO(tmpOutTex);

    const t = paused ? tHold : now();
    const time = t;

    const driftAmt = snap.drift;
    const cineAmt = snap.cine;

    const driftZ = 1.0 + driftAmt*(0.010*Math.sin(time*0.35) + 0.006*Math.sin(time*0.12 + 1.3));
    const driftPX = driftAmt*(0.004*Math.sin(time*0.19 + 0.7));
    const driftPY = driftAmt*(0.003*Math.sin(time*0.23 + 1.9));

    const z = snap.zoom * driftZ;

    // pass 1
    gl.bindFramebuffer(gl.FRAMEBUFFER, tmpSceneFBO);
    gl.viewport(0,0,outW,outH);
    gl.disable(gl.BLEND);

    gl.useProgram(progBH);
    gl.bindVertexArray(quad);
    gl.uniform2f(U.res, outW, outH);
    gl.uniform1f(U.time, time);
    gl.uniform1f(U.zoom, z);
    gl.uniform1f(U.inc, snap.inc);
    gl.uniform1f(U.seed, uSeedVal);
    gl.uniform2f(U.pan, snap.px + driftPX, snap.py + driftPY);
    gl.uniform1f(U.speed, snap.speed);
    gl.uniform1f(U.anom, snap.anom);
    gl.uniform1f(U.cine, cineAmt);
    gl.uniform1f(U.rs, snap.mass);
    gl.uniform1f(U.diskI, snap.diskI);
    gl.uniform1f(U.rout, snap.diskR);
    gl.uniform1f(U.thick, snap.thick);
    gl.uniform1f(U.sparkAmt, snap.sparkAmt);
    gl.uniform1f(U.sparksOn, snap.sparks);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    gl.bindTexture(gl.TEXTURE_2D, tmpSceneTex);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);

    // pass 2
    gl.bindFramebuffer(gl.FRAMEBUFFER, tmpOutFBO);
    gl.viewport(0,0,outW,outH);
    gl.useProgram(progPost);
    gl.bindVertexArray(quad);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tmpSceneTex);
    gl.uniform1i(P.scene, 0);
    gl.uniform2f(P.res, outW, outH);
    gl.uniform1f(P.time, time);
    gl.uniform1f(P.bloom, snap.bloom);
    gl.uniform1f(P.hala, snap.hala);
    gl.uniform1f(P.cine, cineAmt);
    gl.uniform1f(P.autoexp, snap.autoexp);
    gl.uniform1f(P.zoom, z);
    gl.uniform2f(P.pan, snap.px + driftPX, snap.py + driftPY);
    gl.uniform1f(P.rs, snap.mass);
    gl.uniform3f(P.grade, snap.gradeR, snap.gradeG, snap.gradeB);
    gl.uniform1f(P.sat, snap.sat);
    gl.uniform1f(P.contrast, snap.contrast);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // read pixels
    const pixels = new Uint8Array(outW*outH*4);
    gl.bindFramebuffer(gl.FRAMEBUFFER, tmpOutFBO);
    gl.readPixels(0,0,outW,outH, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // cleanup
    gl.deleteFramebuffer(tmpSceneFBO);
    gl.deleteTexture(tmpSceneTex);
    gl.deleteFramebuffer(tmpOutFBO);
    gl.deleteTexture(tmpOutTex);

    // flip Y and download
    const cnv = document.createElement('canvas');
    cnv.width = outW;
    cnv.height = outH;
    const ctx = cnv.getContext('2d');
    const img = ctx.createImageData(outW, outH);

    for(let y=0;y<outH;y++){
      const srcRow = (outH-1-y) * outW * 4;
      const dstRow = y * outW * 4;
      img.data.set(pixels.subarray(srcRow, srcRow + outW*4), dstRow);
    }
    ctx.putImageData(img, 0, 0);

    const blob = await new Promise(res => cnv.toBlob(res, 'image/png'));
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `black-hole_${state.preset}_seed-${state.seed}_${outW}x${outH}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
  }

  shotBtn.addEventListener('click', () => snapshot(2));

  // ---------- main loop ----------
  let tHold = now();
  let last = tHold;
  let fpsAcc=0, fpsN=0, fpsLast=performance.now();

  function step(){
    requestAnimationFrame(step);

    const t = now();
    const dt = clamp(t - last, 0.0, 0.05);
    last = t;

    // Smoothly approach state values
    const a = 1.0 - Math.exp(-dt * 10.0);
    for(const k of LIVE_KEYS){
      live[k] += (state[k] - live[k]) * a;
    }

    // FPS
    const ms = performance.now();
    fpsAcc += 1.0/Math.max(1e-6, dt);
    fpsN++;
    if(ms - fpsLast > 420){
      const avg = fpsAcc / Math.max(1,fpsN);
      fpsEl.textContent = `${avg.toFixed(0)} fps`;
      fpsAcc=0; fpsN=0; fpsLast=ms;
    }

    const time = paused ? tHold : t;
    if(!paused) tHold = time;

    const driftAmt = live.drift;
    const cineAmt = live.cine;

    const driftZ = 1.0 + driftAmt*(0.010*Math.sin(time*0.35) + 0.006*Math.sin(time*0.12 + 1.3));
    const driftPX = driftAmt*(0.004*Math.sin(time*0.19 + 0.7));
    const driftPY = driftAmt*(0.003*Math.sin(time*0.23 + 1.9));

    const z = live.zoom * driftZ;

    // PASS 1
    gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO);
    gl.viewport(0,0,w,h);
    gl.disable(gl.BLEND);

    gl.useProgram(progBH);
    gl.bindVertexArray(quad);

    gl.uniform2f(U.res, w, h);
    gl.uniform1f(U.time, time);
    gl.uniform1f(U.zoom, z);
    gl.uniform1f(U.inc, live.inc);
    gl.uniform1f(U.seed, uSeedVal);
    gl.uniform2f(U.pan, live.px + driftPX, live.py + driftPY);
    gl.uniform1f(U.speed, live.speed);
    gl.uniform1f(U.anom, live.anom);
    gl.uniform1f(U.cine, cineAmt);

    gl.uniform1f(U.rs, live.mass);
    gl.uniform1f(U.diskI, live.diskI);
    gl.uniform1f(U.rout, live.diskR);
    gl.uniform1f(U.thick, live.thick);
    gl.uniform1f(U.sparkAmt, live.sparkAmt);
    gl.uniform1f(U.sparksOn, live.sparks);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    gl.bindTexture(gl.TEXTURE_2D, sceneTex);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);

    // PASS 2
    gl.viewport(0,0,w,h);
    gl.disable(gl.BLEND);
    gl.useProgram(progPost);
    gl.bindVertexArray(quad);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, sceneTex);
    gl.uniform1i(P.scene, 0);

    gl.uniform2f(P.res, w, h);
    gl.uniform1f(P.time, time);
    gl.uniform1f(P.bloom, live.bloom);
    gl.uniform1f(P.hala, live.hala);
    gl.uniform1f(P.cine, cineAmt);
    gl.uniform1f(P.autoexp, live.autoexp);
    gl.uniform1f(P.zoom, z);
    gl.uniform2f(P.pan, live.px + driftPX, live.py + driftPY);
    gl.uniform1f(P.rs, live.mass);

    gl.uniform3f(P.grade, live.gradeR, live.gradeG, live.gradeB);
    gl.uniform1f(P.sat, live.sat);
    gl.uniform1f(P.contrast, live.contrast);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindVertexArray(null);
  }

  // start
  scheduleHashWrite();
  step();

})();
</script>
</body>
</html>
